# -------------------------------------------------------------------------
# [워크플로우 이름] GitHub Actions 탭에서 이 이름으로 표시됩니다.
# -------------------------------------------------------------------------
name: Java CI/CD with Gradle & Docker & AWS

# -------------------------------------------------------------------------
# 1. Trigger (발동 조건)
# -------------------------------------------------------------------------
on:
  # 메인(main) 브랜치에 코드가 'push' 될 때 실행합니다.
  push:
    branches: ["main"]
  # 메인(main) 브랜치를 향해 'PR(Pull Request)'이 생성/업데이트될 때 실행합니다.
  pull_request:
    branches: ["main"]
  # GitHub Actions 탭에서 사람이 직접 'Run workflow' 버튼을 눌러 수동으로 실행할 수 있게 합니다.
  workflow_dispatch:

# -------------------------------------------------------------------------
# 2. Jobs (실제 할 일들)
# -------------------------------------------------------------------------
jobs:
  # =========================================================
  # JOB 1: 빌드 및 도커 푸시 (CI 단계)
  # =========================================================
  build-docker-image:
    # 이 작업이 실행될 환경(VM)입니다. GitHub가 제공하는 최신 우분투를 사용합니다.
    runs-on: ubuntu-latest
    
    # GITHUB_TOKEN의 권한 설정입니다. 소스 코드를 읽어야 하므로 read 권한을 줍니다.
    permissions:
      contents: read
    
    steps:
      # (1) 깃허브 레포지토리의 소스 코드를 현재 실행 중인 우분투 VM으로 내려받습니다.
      - name: Checkout Source Code
        uses: actions/checkout@v4

      # (2) 자바 17 버전을 설치합니다. (Spring Boot 3.x 이상은 17 필수)
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin' # Eclipse Temurin 배포판(가장 표준적임)을 사용합니다.

      # (3) Gradle 빌드 속도를 높이기 위해 캐싱을 설정합니다.
      # 이전에 받은 라이브러리(.gradle 폴더)가 있다면 다시 다운받지 않고 재사용합니다.
      - name: Gradle Caching
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches    # 의존성 라이브러리가 저장되는 곳
            ~/.gradle/wrapper   # 그레이들 래퍼 자체가 저장되는 곳
          # 캐시를 식별하는 키입니다. OS와 gradle 관련 파일들의 해시값을 조합해 만듭니다.
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          # 일치하는 키가 없을 경우, 이전 버전의 캐시라도 가져오도록 시도합니다.
          restore-keys: |
            ${{ runner.os }}-gradle-

      # (4) gradlew 스크립트에 실행 권한(+x)을 줍니다. (리눅스에서 실행하려면 필수)
      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      # (5) 실제 빌드를 수행합니다.
      # clean: 이전 빌드 산출물 삭제 / bootJar: 실행 가능한 Spring Boot Jar 파일 생성
      - name: Build with Gradle
        run: ./gradlew clean bootJar

      # (6) 만들어진 이미지를 올리기 위해 Docker Hub에 로그인합니다.
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }} # GitHub Secrets에 저장된 ID
          password: ${{ secrets.DOCKER_PASSWORD }} # GitHub Secrets에 저장된 PW

      # (7) Docker 이미지를 빌드하고 Hub로 푸시합니다.
      - name: Build and Push to Docker Hub
        uses: docker/build-push-action@v5
        with:
          context: .      # Dockerfile이 있는 위치 (현재 폴더)
          push: true      # 빌드 후 바로 푸시할 것인지 여부
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/my-spring-boot-app_2_13:latest
            ${{ secrets.DOCKER_USERNAME }}/my-spring-boot-app_2_13:${{ github.sha }}

  # =========================================================
  # JOB 2: AWS EC2 배포 (CD 단계)
  # =========================================================
  deploy:
    # [핵심 의존성] 위의 'build-docker-image' 작업이 성공해야만 이 작업이 시작됩니다.
    needs: build-docker-image
    # 마찬가지로 우분투 환경에서 실행합니다. (이 우분투는 EC2가 아니라 GitHub의 러너입니다)
    runs-on: ubuntu-latest
    
    # AWS OIDC(OpenID Connect) 인증을 사용하기 위해 id-token 쓰기 권한이 필수입니다.
    permissions:
      id-token: write
      contents: read

    steps:
      # (1) AWS 자격 증명을 획득합니다. (AccessKey 없이 Role을 임시로 빌려 쓰는 방식)
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # GitHub Actions가 흉내 낼(Assume) IAM 역할의 ARN 주소
          role-to-assume: ${{ secrets.ROLE_TO_ASSUME }}
          aws-region: ap-northeast-2 # 한국 리전

      # (2) AWS SSM(Systems Manager)을 통해 EC2 내부로 명령어를 원격 전송합니다.
      # SSH 키 없이 안전하게 접속하는 방식입니다.
      - name: Deploy to EC2 via AWS CLI
        run: |
          aws ssm send-command \
            --instance-ids "${{ secrets.EC2_INSTANCE_ID }}" \
            --region ap-northeast-2 \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /home/ubuntu/cicd",
              "echo \"${{ secrets.ENV_PROPERTIES }}\" > .env",
              "chmod 600 .env",
              "docker-compose pull",
              "docker-compose down",
              "docker-compose up -d",
              "docker image prune -f"
            ]' \
            --comment "Deploying application via GitHub Actions"
